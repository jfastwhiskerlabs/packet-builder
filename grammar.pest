// ===============================
// Lexical conveniences
// ===============================
WHITESPACE = _{ " " | "\t" | "\n" | "\r\n" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* }

// Basic character classes
alpha  = @{ 'a'..'z' | 'A'..'Z' }
digit  = @{ '0'..'9' }
bindig = @{ '0'..'1' }
hexdig = @{ '0'..'9' | 'a'..'f' | 'A'..'F' }
alnum  = @{ alpha | digit }
underscore = @{ "_" }

// ===============================
// Operators & punctuation (prefer longest-first)
// ===============================
plus   = @{ "+" }
minus  = @{ "-" }
mult   = @{ "*" }
div    = @{ "/" }
pw     = @{ "^" }

lparen = @{ "(" }
rparen = @{ ")" }
lbracket = @{ "{" }
rbracket = @{ "}" }
larray = @{ "[" }
rarray = @{ "]" }
comma  = @{ "," }
assign = @{ "=" }          

gt   = @{ ">" }
gte  = @{ ">=" }
lt   = @{ "<" }
lte  = @{ "<=" }          
eq   = @{ "==" }
neq  = @{ "!=" | "<>" }

// Logical
and_kw = @{ "and" }
or_kw  = @{ "or" }

// Aggregates / control
sumof_kw      = @{ "sumof" }
productof_kw  = @{ "productof" }
when_kw       = @{ "when" }
then_kw       = @{ "then" }
otherwise_kw  = @{ "otherwise" }

// Packet keywords
packet_kw     = @{ "packet" }
calc_kw       = @{ "calc" }

// Intrinsics
sqrt_kw = @{ "sqrt" }
min_kw  = @{ "min" }
max_kw  = @{ "max" }

// Endianness
le_kw = @{ "le" }
be_kw = @{ "be" }

// ===============================
// Keyword reservation
// ===============================
keyword = _{
    packet_kw | calc_kw
  | when_kw | then_kw | otherwise_kw
  | sumof_kw | productof_kw
  | and_kw | or_kw
  | sqrt_kw | min_kw | max_kw
  | le_kw | be_kw
  // types are also reserved (see below)
}

// ===============================
// Identifiers & numbers
// ===============================
// Disallow keywords as identifiers:
identifier = @{ !keyword ~ (alpha | underscore) ~ (alnum | underscore)* }

// Numbers: decimal, hex (0x...), and binary (0b...)
numeric_constant = @{
      ("0x" ~ hexdig+)
    | ("0b" ~ bindig+)
    | (digit+ ~ ("." ~ digit+)?)
}

// ===============================
// Strings (JSON-style escapes)
// ===============================
string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char* }
char   = {
      !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ hexdig{4})
}

// ===============================
// Types
// ===============================
int8    = @{ "int8" }
uint8   = @{ "uint8" }
int16   = @{ "int16" }
uint16  = @{ "uint16" }
int32   = @{ "int32" }
uint32  = @{ "uint32" }
int64   = @{ "int64" }
uint64  = @{ "uint64" }
float32 = @{ "float32" }
float64 = @{ "float64" }
macaddr = @{ "macaddress" }
datetime= @{ "datetime" }
bytes_t = @{ "bytes" }     // NEW: raw byte blob

type_name = @{
    int8 | uint8 | int16 | uint16 | int32 | uint32 | int64 | uint64
  | float32 | float64 | macaddr | datetime | bytes_t
}

// Keep types reserved:
keyword_or_type = _{ keyword | type_name }

// Endianness specifier (optional per packet/field)
endianness = @{ le_kw | be_kw }

// ===============================
// Expressions (precedence: or < and < comparison < +,- < *,/ < ^ < primary)
// ===============================
expr            = { bool_or }
bool_or         = { bool_and ~ (or_kw  ~ bool_and )* }
bool_and        = { cmp      ~ (and_kw ~ cmp      )* }
cmp             = { sum ~ ((gte|lte|gt|lt|eq|neq) ~ sum)* }
sum             = { product ~ ((plus | minus) ~ product)* }
product         = { power   ~ ((mult | div)  ~ power  )* }
power           = { primary ~ (pw ~ primary)? }

primary         = { guard_expression | literal | function_call | accessor | inner_expr }

inner_expr      = { lparen ~ expr ~ rparen }
literal         = { numeric_constant | string }

// Function calls
intrinsic_function = @{ sqrt_kw | min_kw | max_kw }
parameter_list = { lparen ~ (expr ~ (comma ~ expr)*)? ~ comma? ~ rparen } // allows trailing comma
function_call = { intrinsic_function ~ parameter_list }

// Accessors & declarations
declaration = { identifier ~ type_name ~ array_specifier? ~ endianness? }
accessor    = { aggregate_accessor | direct_value_accessor }

direct_value_accessor = { identifier ~ array_specifier? }
aggregate_accessor    = { (sumof_kw | productof_kw) ~ identifier ~ !larray }

// Arrays: allow dynamic length via full expr, not just numeric constant
array_specifier = { larray ~ expr ~ rarray }

// Guarded (ternary-like) expression usable anywhere an expr is allowed
guard_expression = { when_kw ~ expr ~ then_kw ~ expr ~ otherwise_kw ~ expr }

// ===============================
// Packets
// ===============================
packets = { SOI ~ packet+ ~ EOI }

packet  = {
  packet_kw ~ identifier ~ endianness? ~ lbracket ~ rule_list? ~ rbracket
}

rule_list = { rule ~ (comma ~ rule)* ~ comma? }

rule = { declaration | calculated_field }

calculated_field = { calc_kw ~ identifier ~ type_name ~ assign ~ expr }
